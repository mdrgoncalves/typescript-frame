<h1 align="center">
    Alura Frame
</h1>

<p align="center">
 ‚Ä¢ <a href="#-about">Sobre</a> 
 ‚Ä¢ <a href="#-tech-stack">Conte√∫do Estudado</a>  
</p>

# üíª Sobre

Alura Frame - P√°gina para estudo de TypeScript.

---

# üõ† Conte√∫do Estudado

<details>

<summary><b><font size="+2">M√ìDULO 1 - EVOLUINDO O JAVASCRIPT</font></b></summary>

## T√ìPICO 1: B√°sico do TS

 - **Diferen√ßas do JS para TS**
 
Uma das principais diferen√ßas √© que o TS √© tipado, ou seja, voc√™ precisa definir o tipo de cada vari√°vel, fun√ß√£o, etc. E isso √© muito bom, pois o TS vai te ajudar a evitar erros de digita√ß√£o, por exemplo, e tamb√©m vai te ajudar a entender melhor o que cada coisa faz.
<br/><br/>

## T√ìPICO 2: Configura√ß√£o do TS

 - **Instala√ß√£o do TS**

Para instalar o TS, precisa-se ter o NodeJS instalado na m√°quina. Depois, basta rodar o comando npm install -g typescript.

 - **Configura√ß√£o do TS**

Para configurar o TS, precisa-se criar um arquivo chamado tsconfig.json. Nele, se pode definir o diret√≥rio de sa√≠da do arquivo compilado, o diret√≥rio de entrada do arquivo TS, o modo de compila√ß√£o, etc. 

    {
    "compilerOptions": {
        "outDir": "dist/js", //Diret√≥rio de sa√≠da do arquivo compilado
        "target": "ES6", //Vers√£o do JS que o TS vai compilarenter code here
        "noEmitOnError": true //Se houver algum erro, n√£o compila o arquivo
    },
    "include": ["app/**/*"] //Diret√≥rio de entrada do arquivo TS
    }

 
 - **Modificador PRIVATE**

O modificador PRIVATE √© usado para definir que um atributo ou m√©todo s√≥ pode ser acessado dentro da classe que ele foi declarado. 
<br/><br/>

## T√ìPICO 3 - Tipagens

 - **Tipo impl√≠cito ANY**

O tipo ANY √© um tipo que pode receber qualquer tipo de dado. Ele √© muito √∫til quando voc√™ n√£o sabe o tipo de dado que vai receber, mas n√£o √© recomendado us√°-lo.

Para retirar o tipo ANY, pode-se usar o comando tsc "noImplicitAny": true no tsconfig. Ele vai mostrar todos os erros de tipagem que se tem no c√≥digo.

- **Tipo HTMLElement**

O tipo HTMLElement √© um tipo que representa um elemento HTML. Muito √∫til para se trabalhar com elementos HTML.
<br/><br/>

## T√ìPICO 4 - Avan√ßando em TS

 - **Generics**

Generics em TS s√£o como templates, servem para definir um tipo gen√©rico que pode ser usado em qualquer lugar. Por exemplo: Array<T> √© um array que pode receber qualquer tipo de dado.

- **Modificador READONLY**

O modificador READONLY √© usado para definir que um atributo s√≥ pode ser lido, mas n√£o pode ser alterado. Por exemplo: ReadOnlyArray<T> √© um array que s√≥ pode ser lido, mas n√£o pode ser alterado.
<br/><br/>

## T√ìPICO 5 - Simplifica√ß√µes no TS

- **Declara√ß√£o no Constructor**

√â poss√≠vel declarar atributos no constructor, sem precisar declarar no escopo da classe. Se no construtor da classe utilizar public ou private antes do atributo, ele vai ser declarado no escopo da classe.

- **Atalho para Array**

Para declarar um array, pode-se usar o atalho T[], no lugar de Array<T>.
Para o modificador READONLY, pode-se usar o atalho readonly T[], no lugar de ReadonlyArray<T>.

- **Getters P√∫blicos**

Se a propriedade de uma classe estiver sendo utilizada apenas para leitura, pode-se declarar no constructor da classe a mesma como p√∫blica e utilizando o modificador readonly. Dessa forma, n√£o √© necess√°rio criar um getter para a propriedade.

- **Programa√ß√£o Defensiva com Datas**

Pelo Date conter m√©todos que podem alterar o valor da data quando essa √© passada como par√¢metro, √© recomendado criar uma c√≥pia da data para fornec√™-la como getter.
<br/><br/>

</details>

<details>

<summary><b><font size="+2">M√ìDULO 2 - AVAN√áANDO EM TYPESCRIPT</font></b></summary>

## T√ìPICO 1: Manipula√ß√£o de DOM

- **Templates Declarativos e Din√¢micos**

Templates declarativos s√£o templates que s√£o declarados no HTML e s√£o utilizados para renderizar elementos HTML. Templates din√¢micos s√£o templates que s√£o declarados no TS e s√£o utilizados para renderizar elementos HTML.

- **Formata√ß√£o de Datas usando Intl**

Para formatar datas, pode-se usar o Intl, que √© um objeto que possui m√©todos para formatar datas, moedas, n√∫meros, etc.
<br/><br/>

## T√ìPICO 2: Heran√ßas

- **Aplica√ß√£o do EXTENDS**

O extends √© usado para herdar atributos e m√©todos de uma classe. 

- **Modificador PROTECTED**

O modificador protected √© usado para definir que um atributo ou m√©todo s√≥ pode ser acessado dentro da classe que ele foi declarado ou nas classes que herdam essa classe.

- **Generics em Heran√ßa**

√â poss√≠vel utilizar generics em heran√ßa. Por exemplo: class ClassePai<T> extends Pai<T>.
O <T> define um tipo gen√©rico, permitindo criar m√©todos que recebam esse mesmo tipo, aumentando o reaproveitamento de c√≥digo entre pais e filhos.

- **O ABSTRACT**

O abstract √© usado para definir que uma classe n√£o pode ser instanciada, mas pode ser herdada. Uma classe abstrata pode ter m√©todos abstratos, que s√£o m√©todos que n√£o possuem implementa√ß√£o, mas que devem ser implementados nas classes filhas.
<br/><br/>

## T√ìPICO 3: Enumerations

- **ENUM**

O enum √© usado para definir um conjunto de constantes. Por exemplo: enum DiasDaSemana {Segunda, Ter√ßa, Quarta, Quinta, Sexta, S√°bado, Domingo}. O enum √© um tipo de dado, ent√£o pode ser utilizado em qualquer lugar que se possa utilizar um tipo de dado.

- **ENUM COM VALORES**

√â poss√≠vel definir valores para cada constante do enum. Isso garante a seguran√ßa da ordem do enum, pois se uma constante for adicionada no meio do enum, as outras constantes n√£o ser√£o alteradas. 
<br/><br/>

## T√ìPICO 4 - Static e Opcionais

- **Modificador STATIC**

O static √© usado para definir que um atributo ou m√©todo pertence √† classe, e n√£o √† inst√¢ncia da classe, sendo assim, n√£o √© necess√°rio instanciar a classe para acessar o atributo ou m√©todo.

- **Prote√ß√£o do innerHTML**

Para proteger o innerHTML, pode-se utilizar um escape para evitar que seja inserido a tag script no HTML. Como √© o caso utilizando o REGEX: innerHTML = texto.replace(/<script>[\s\S]*?<\/script>/, '');

- **Opcionais**

√â poss√≠vel definir que um atributo ou par√¢metro √© opcional, utilizando o s√≠mbolo de interroga√ß√£o (?) ap√≥s o nome do atributo ou par√¢metro. Isso permite que o atributo ou par√¢metro n√£o seja obrigat√≥rio, podendo ser passado ou n√£o.
<br/><br/>

## T√ìPICO 5 - Ambientes R√≠gidos

- **Remo√ß√£o de Coment√°rios na Compila√ß√£o**

Para remover coment√°rios na compila√ß√£o, pode-se utilizar o par√¢metro --removeComments no tsconfig.json.

- **StrictNullChecks**

O strictNullChecks √© um par√¢metro do tsconfig.json que permite que o TS n√£o aceite atribui√ß√µes de null ou undefined para vari√°veis que n√£o s√£o do tipo any ou que n√£o possuem o s√≠mbolo de interroga√ß√£o (?) ap√≥s o nome do atributo ou par√¢metro.

- **Casting Expl√≠cito**

O casting expl√≠cito √© uma forma de for√ßar o TS a aceitar atribui√ß√µes de null ou undefined para vari√°veis que n√£o s√£o do tipo any ou que n√£o possuem o s√≠mbolo de interroga√ß√£o (?) ap√≥s o nome do atributo ou par√¢metro. Para isso, pode-se inferir explicitamente o tipo da var√≠avel, utilizando "... as Tipo" ap√≥s a declara√ß√£o da vari√°vel ou <Tipo> antes da declara√ß√£o da vari√°vel.
<br/><br/>

</details>

<details>

<summary><b><font size="+2">M√ìDULO 3 - T√âCNICAS E BOAS PR√ÅTICAS</font></b></summary>

## T√ìPICO 1: Requisitos N√£o Funcionais e Decorators

- **Performance Now**

O performance.now() √© um m√©todo que retorna o tempo em milissegundos desde que a p√°gina foi carregada. Esse m√©todo √© √∫til para medir o tempo de execu√ß√£o de um trecho de c√≥digo.

- **Decorators**

Os decorators s√£o fun√ß√µes que podem ser aplicadas a classes, m√©todos, atributos e par√¢metros. Eles s√£o usados para adicionar funcionalidades a esses elementos. Para aplicar um decorator, basta colocar o s√≠mbolo @ antes da declara√ß√£o do elemento. Por exemplo: @logarTempoDeExecu√ß√£o.

- **Compila√ß√£o do Decorator**

Para ativar a compila√ß√£o dos decorators no c√≥digo, √© necess√°rio adicionar o par√¢metro "experimentalDecorators": true no tsconfig.json.

- **Par√¢metros do Decorator**

```typescript
    function decorator() {

        return function(
            target: any, 
            /*
                Se colocar o decorator em um m√©todo est√°tico, o target √© a fun√ß√£o construtora
                Se colocar o decorator em um m√©todo de inst√¢ncia, o target √© o prototype da fun√ß√£o construtora
            */
            propertyKey: string,
            /*
                Se colocar o decorator em um atributo, o propertyKey √© o nome do atributo
                Se colocar o decorator em um par√¢metro, o propertyKey √© o nome do m√©todo
            */
            descriptor: PropertyDescriptor
            /*
                Se colocar o decorator em um m√©todo, o descriptor d√° acesso ao m√©todo
            */
        )
    }
```
<br/><br/>

## T√ìPICO 2: Decorators de M√©todos

- **Template do Decorator**

```typescript
    export function decorator() {

        return function(
            target: any,
            key: string,
            descriptor: PropertyDescriptor
        ) {
            const metodoOriginal = descriptor.value;

            descriptor.value = function(...args: any[]) {

                const retorno = metodoOriginal.apply(this, args);
                return retorno;
            };

            return descriptor;
        }
    }
```

- **Simplificando um Decorator**

Se um decorator n√£o tiver nenhum par√¢metro, n√£o √© necess√°rio chamar um wrapper. Por exemplo:

```typescript
    return decorator(
        target: any,
        key: string,
        descriptor: PropertyDescriptor
    ) {
        const metodoOriginal = descriptor.value;

        descriptor.value = function(...args: any[]) {

            const retorno = metodoOriginal.apply(this, args);
            return retorno;
        };

        return descriptor;
    }
```
<br/><br/>

## T√ìPICO 3: Decorators de Propriedades

- **Getters Din√¢micos**

Para que seja poss√≠vel o decorator acessar o atributo atrav√©s de alguma inst√¢ncia da classe, √© necess√°rio criar um getter din√¢mico para o atributo. Para isso, basta criar um getter para o atributo, que retorna o valor do atributo da inst√¢ncia da classe.

- **Redefinir Getter**

Para redefinir o getter, √© necess√°rio utilizar o Object.defineProperty. Este sobrescrever√° o getter original, criando uma nova refer√™ncia no prototype, permitindo que o decorator acesse o atributo atrav√©s de alguma inst√¢ncia da classe.

- **Cache Decorator Copy**

Para evitar que o decorator seja aplicado v√°rias vezes ao mesmo atributo, √© necess√°rio criar um cache para o decorator. Para isso, cria-se uma verifica√ß√£o no decorator para verificar se o atributo j√° foi decorado. Caso n√£o tenha sido, o decorator √© aplicado ao atributo. Caso j√° tenha sido, o decorator n√£o √© aplicado novamente.
<br/><br/>

## T√ìPICO 4: API Externa e Interface

- **Interfaces**

As interfaces s√£o formas de definir um contrato para uma classe. Elas s√£o √∫teis para definir o que uma classe deve ter, mas n√£o como ela deve ter. Para criar uma interface, basta utilizar a palavra interface seguida do nome da interface. 

- **Implementando uma Interface**

Para implementar uma interface, basta utilizar a palavra implements seguida do nome da interface. 

- **Services**

Os services s√£o classes que cont√©m m√©todos que acessam uma API externa. Eles s√£o √∫teis para isolar a l√≥gica de acesso a uma API externa, permitindo que a l√≥gica de neg√≥cio da aplica√ß√£o n√£o seja afetada caso a API externa mude.
<br/><br/>

## T√ìPICO 5: Evoluindo Interfaces

- **Polimorfismo**

O polimorfismo √© um conceito que permite que uma classe tenha m√©todos com o mesmo nome, mas que fa√ßam coisas diferentes. Para isso, pode-se utilizar interfaces. 

- **Interfaces com Generics**

As interfaces podem ser parametrizadas, permitindo que sejam utilizadas com diferentes tipos de dados. Para isso, basta utilizar o s√≠mbolo <T> antes do nome da interface.

- **Estendendo Interfaces**

Para estender uma interface, basta utilizar a palavra extends seguida do nome da interface. As interfaces podem ser estendidas um n√∫mero ilimitados de vezes, ao contr√°rio das classes.

- **SourceMap**

O sourceMap √© um arquivo que mapeia o c√≥digo transpilado para o c√≥digo original. Ele √© √∫til para debugar o c√≥digo original, mesmo que o c√≥digo transpilado esteja sendo executado. Para gerar o sourceMap, basta adicionar o par√¢metro "sourceMap": true no tsconfig.json. Para o debug ocorrer de forma correta, tanto o c√≥digo compilado quanto a ser compilado devem estar na mesma estrutura de pastas.

</details>